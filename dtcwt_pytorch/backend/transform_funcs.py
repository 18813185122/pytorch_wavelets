'''This file was automatically generated by running transform_templates.py'''
import torch
from torch.autograd import Function
from dtcwt_pytorch.backend.lowlevel import colfilter, rowfilter
from dtcwt_pytorch.backend.lowlevel import coldfilt, rowdfilt
from dtcwt_pytorch.backend.lowlevel import colifilt, rowifilt, q2c, c2q

class ifm1(Function):

    @staticmethod
    def forward(ctx, yl, yh1, g0o, g1o, g0a, g0b, g1a, g1b):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.calc_gradients = yl.requires_grad
        batch, ch, r, c = yl.shape
        ll = yl
        # Level 1 inverse with biorthogonal synthesis filters
        lh = c2q(yh1[:,:,0:6:5])
        hl = c2q(yh1[:,:,2:4:1])
        hh = c2q(yh1[:,:,1:5:3])
        Hi = colfilter(hh, g1o) + colfilter(hl, g0o)
        Lo = colfilter(lh, g1o) + colfilter(ll, g0o)
        y = rowfilter(Hi, g1o) + rowfilter(Lo, g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if ctx.calc_gradients:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            Hi = rowfilter(grad_y, g1o_t)
            LoHi = colfilter(Lo, g1o_t)
            HiLo = colfilter(Hi, g0o_t)
            HiHi = colfilter(Hi, g1o_t)
            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

            grad_yl = LoLo

        return grad_yl, grad_yh1, None, None, None, None, None, None


class xfm1(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b):
        ctx.save_for_backward(input.shape, h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.calc_gradients = input.requires_grad
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        LoLo = colfilter(Lo, h0o)
        Hi = rowfilter(input, h1o)
        LoHi = colfilter(Lo, h1o)
        HiLo = colfilter(Hi, h0o)
        HiHi = colfilter(Hi, h1o)
        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh1 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        Yl = LoLo
        return Yl, Yh1

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1):
        in_shape, h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if ctx.calc_gradients:
            ll = grad_LoLo
            # Level 1 backward (time reversed biorthogonal analysis filters)
            lh = c2q(grad_Yh1[:,:,0:6:5])
            hl = c2q(grad_Yh1[:,:,2:4:1])
            hh = c2q(grad_Yh1[:,:,1:5:3])
            Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
            Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
            grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)

        return (grad_input,) + (None,) * 6


class ifm1no_l1(Function):

    @staticmethod
    def forward(ctx, yl, yh1, g0o, g1o, g0a, g0b, g1a, g1b):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.calc_gradients = yl.requires_grad
        batch, ch, r, c = yl.shape
        ll = yl
        # Level 1 inverse - no highpasses so only use the
        # Low-low band with biorthogonal synthesis filters
        y = rowfilter(colfilter(ll, g0o), g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if ctx.calc_gradients:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            # No more processing - hps coeffs are 0
            grad_yl = LoLo

        return grad_yl, grad_yh1, None, None, None, None, None, None


class xfm1no_l1(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b):
        ctx.save_for_backward(input.shape, h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.calc_gradients = input.requires_grad
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        LoLo = colfilter(Lo, h0o)
        Yh1 = torch.tensor([])

        Yl = LoLo
        return Yl, Yh1

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1):
        in_shape, h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if ctx.calc_gradients:
            ll = grad_LoLo
            # Level 1 backward (time reversed biorthogonal analysis filters). No
            # Highpasses so only need to use the low-low
            grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)

        return (grad_input,) + (None,) * 6


class ifm2(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, g0o, g1o, g0a, g0b, g1a, g1b):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.calc_gradients = yl.requires_grad
        batch, ch, r, c = yl.shape
        ll = yl
        # Level 2 inverse transform with quater shift synthesis filters
        lh = c2q(yh2[:,:,0:6:5])
        hl = c2q(yh2[:,:,2:4:1])
        hh = c2q(yh2[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh1.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]
        # Level 1 inverse with biorthogonal synthesis filters
        lh = c2q(yh1[:,:,0:6:5])
        hl = c2q(yh1[:,:,2:4:1])
        hh = c2q(yh1[:,:,1:5:3])
        Hi = colfilter(hh, g1o) + colfilter(hl, g0o)
        Lo = colfilter(lh, g1o) + colfilter(ll, g0o)
        y = rowfilter(Hi, g1o) + rowfilter(Lo, g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if ctx.calc_gradients:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            Hi = rowfilter(grad_y, g1o_t)
            LoHi = colfilter(Lo, g1o_t)
            HiLo = colfilter(Hi, g0o_t)
            HiHi = colfilter(Hi, g1o_t)
            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            grad_yl = LoLo

        return grad_yl, grad_yh1, grad_yh2, None, None, None, None, None, None


class xfm2(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b):
        ctx.save_for_backward(input.shape, h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.calc_gradients = input.requires_grad
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        LoLo = colfilter(Lo, h0o)
        Hi = rowfilter(input, h1o)
        LoHi = colfilter(Lo, h1o)
        HiLo = colfilter(Hi, h0o)
        HiHi = colfilter(Hi, h1o)
        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh1 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh2 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        Yl = LoLo
        return Yl, Yh1, Yh2

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2):
        in_shape, h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if ctx.calc_gradients:
            ll = grad_LoLo
            # Level 2 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh2[:,:,0:6:5])
            hl = c2q(grad_Yh2[:,:,2:4:1])
            hh = c2q(grad_Yh2[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters)
            lh = c2q(grad_Yh1[:,:,0:6:5])
            hl = c2q(grad_Yh1[:,:,2:4:1])
            hh = c2q(grad_Yh1[:,:,1:5:3])
            Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
            Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
            grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)

        return (grad_input,) + (None,) * 6


class ifm2no_l1(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, g0o, g1o, g0a, g0b, g1a, g1b):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.calc_gradients = yl.requires_grad
        batch, ch, r, c = yl.shape
        ll = yl
        # Level 2 inverse transform with quater shift synthesis filters
        lh = c2q(yh2[:,:,0:6:5])
        hl = c2q(yh2[:,:,2:4:1])
        hh = c2q(yh2[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)

        # Level 1 inverse - no highpasses so only use the
        # Low-low band with biorthogonal synthesis filters
        y = rowfilter(colfilter(ll, g0o), g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if ctx.calc_gradients:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            # No more processing - hps coeffs are 0
            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            grad_yl = LoLo

        return grad_yl, grad_yh1, grad_yh2, None, None, None, None, None, None


class xfm2no_l1(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b):
        ctx.save_for_backward(input.shape, h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.calc_gradients = input.requires_grad
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        LoLo = colfilter(Lo, h0o)
        Yh1 = torch.tensor([])

        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh2 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        Yl = LoLo
        return Yl, Yh1, Yh2

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2):
        in_shape, h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if ctx.calc_gradients:
            ll = grad_LoLo
            # Level 2 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh2[:,:,0:6:5])
            hl = c2q(grad_Yh2[:,:,2:4:1])
            hh = c2q(grad_Yh2[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = in_shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters). No
            # Highpasses so only need to use the low-low
            grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)

        return (grad_input,) + (None,) * 6


class ifm3(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, yh3, g0o, g1o, g0a, g0b, g1a, g1b):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.calc_gradients = yl.requires_grad
        batch, ch, r, c = yl.shape
        ll = yl
        # Level 3 inverse transform with quater shift synthesis filters
        lh = c2q(yh3[:,:,0:6:5])
        hl = c2q(yh3[:,:,2:4:1])
        hh = c2q(yh3[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh2.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 2 inverse transform with quater shift synthesis filters
        lh = c2q(yh2[:,:,0:6:5])
        hl = c2q(yh2[:,:,2:4:1])
        hh = c2q(yh2[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh1.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]
        # Level 1 inverse with biorthogonal synthesis filters
        lh = c2q(yh1[:,:,0:6:5])
        hl = c2q(yh1[:,:,2:4:1])
        hh = c2q(yh1[:,:,1:5:3])
        Hi = colfilter(hh, g1o) + colfilter(hl, g0o)
        Lo = colfilter(lh, g1o) + colfilter(ll, g0o)
        y = rowfilter(Hi, g1o) + rowfilter(Lo, g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None
        grad_yh3 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if ctx.calc_gradients:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            Hi = rowfilter(grad_y, g1o_t)
            LoHi = colfilter(Lo, g1o_t)
            HiLo = colfilter(Hi, g0o_t)
            HiHi = colfilter(Hi, g1o_t)
            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 3 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            grad_yl = LoLo

        return grad_yl, grad_yh1, grad_yh2, grad_yh3, None, None, None, None, None, None


class xfm3(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b):
        ctx.save_for_backward(input.shape, h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.calc_gradients = input.requires_grad
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        LoLo = colfilter(Lo, h0o)
        Hi = rowfilter(input, h1o)
        LoHi = colfilter(Lo, h1o)
        HiLo = colfilter(Hi, h0o)
        HiHi = colfilter(Hi, h1o)
        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh1 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh2 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh3 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        Yl = LoLo
        return Yl, Yh1, Yh2, Yh3

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2, grad_Yh3):
        in_shape, h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if ctx.calc_gradients:
            ll = grad_LoLo
            # Level 3 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh3[:,:,0:6:5])
            hl = c2q(grad_Yh3[:,:,2:4:1])
            hh = c2q(grad_Yh3[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 2 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh2[:,:,0:6:5])
            hl = c2q(grad_Yh2[:,:,2:4:1])
            hh = c2q(grad_Yh2[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters)
            lh = c2q(grad_Yh1[:,:,0:6:5])
            hl = c2q(grad_Yh1[:,:,2:4:1])
            hh = c2q(grad_Yh1[:,:,1:5:3])
            Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
            Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
            grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)

        return (grad_input,) + (None,) * 6


class ifm3no_l1(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, yh3, g0o, g1o, g0a, g0b, g1a, g1b):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.calc_gradients = yl.requires_grad
        batch, ch, r, c = yl.shape
        ll = yl
        # Level 3 inverse transform with quater shift synthesis filters
        lh = c2q(yh3[:,:,0:6:5])
        hl = c2q(yh3[:,:,2:4:1])
        hh = c2q(yh3[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh2.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 2 inverse transform with quater shift synthesis filters
        lh = c2q(yh2[:,:,0:6:5])
        hl = c2q(yh2[:,:,2:4:1])
        hh = c2q(yh2[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)

        # Level 1 inverse - no highpasses so only use the
        # Low-low band with biorthogonal synthesis filters
        y = rowfilter(colfilter(ll, g0o), g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None
        grad_yh3 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if ctx.calc_gradients:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            # No more processing - hps coeffs are 0
            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 3 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            grad_yl = LoLo

        return grad_yl, grad_yh1, grad_yh2, grad_yh3, None, None, None, None, None, None


class xfm3no_l1(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b):
        ctx.save_for_backward(input.shape, h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.calc_gradients = input.requires_grad
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        LoLo = colfilter(Lo, h0o)
        Yh1 = torch.tensor([])

        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh2 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh3 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        Yl = LoLo
        return Yl, Yh1, Yh2, Yh3

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2, grad_Yh3):
        in_shape, h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if ctx.calc_gradients:
            ll = grad_LoLo
            # Level 3 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh3[:,:,0:6:5])
            hl = c2q(grad_Yh3[:,:,2:4:1])
            hh = c2q(grad_Yh3[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 2 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh2[:,:,0:6:5])
            hl = c2q(grad_Yh2[:,:,2:4:1])
            hh = c2q(grad_Yh2[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = in_shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters). No
            # Highpasses so only need to use the low-low
            grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)

        return (grad_input,) + (None,) * 6


class ifm4(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, yh3, yh4, g0o, g1o, g0a, g0b, g1a, g1b):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.calc_gradients = yl.requires_grad
        batch, ch, r, c = yl.shape
        ll = yl
        # Level 4 inverse transform with quater shift synthesis filters
        lh = c2q(yh4[:,:,0:6:5])
        hl = c2q(yh4[:,:,2:4:1])
        hh = c2q(yh4[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh3.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 3 inverse transform with quater shift synthesis filters
        lh = c2q(yh3[:,:,0:6:5])
        hl = c2q(yh3[:,:,2:4:1])
        hh = c2q(yh3[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh2.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 2 inverse transform with quater shift synthesis filters
        lh = c2q(yh2[:,:,0:6:5])
        hl = c2q(yh2[:,:,2:4:1])
        hh = c2q(yh2[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh1.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]
        # Level 1 inverse with biorthogonal synthesis filters
        lh = c2q(yh1[:,:,0:6:5])
        hl = c2q(yh1[:,:,2:4:1])
        hh = c2q(yh1[:,:,1:5:3])
        Hi = colfilter(hh, g1o) + colfilter(hl, g0o)
        Lo = colfilter(lh, g1o) + colfilter(ll, g0o)
        y = rowfilter(Hi, g1o) + rowfilter(Lo, g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None
        grad_yh3 = None
        grad_yh4 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if ctx.calc_gradients:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            Hi = rowfilter(grad_y, g1o_t)
            LoHi = colfilter(Lo, g1o_t)
            HiLo = colfilter(Hi, g0o_t)
            HiHi = colfilter(Hi, g1o_t)
            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 3 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 4 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh4 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            grad_yl = LoLo

        return grad_yl, grad_yh1, grad_yh2, grad_yh3, grad_yh4, None, None, None, None, None, None


class xfm4(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b):
        ctx.save_for_backward(input.shape, h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.calc_gradients = input.requires_grad
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        LoLo = colfilter(Lo, h0o)
        Hi = rowfilter(input, h1o)
        LoHi = colfilter(Lo, h1o)
        HiLo = colfilter(Hi, h0o)
        HiHi = colfilter(Hi, h1o)
        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh1 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh2 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh3 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 4 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh4 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        Yl = LoLo
        return Yl, Yh1, Yh2, Yh3, Yh4

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2, grad_Yh3, grad_Yh4):
        in_shape, h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if ctx.calc_gradients:
            ll = grad_LoLo
            # Level 4 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh4[:,:,0:6:5])
            hl = c2q(grad_Yh4[:,:,2:4:1])
            hh = c2q(grad_Yh4[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh3.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 3 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh3[:,:,0:6:5])
            hl = c2q(grad_Yh3[:,:,2:4:1])
            hh = c2q(grad_Yh3[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 2 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh2[:,:,0:6:5])
            hl = c2q(grad_Yh2[:,:,2:4:1])
            hh = c2q(grad_Yh2[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters)
            lh = c2q(grad_Yh1[:,:,0:6:5])
            hl = c2q(grad_Yh1[:,:,2:4:1])
            hh = c2q(grad_Yh1[:,:,1:5:3])
            Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
            Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
            grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)

        return (grad_input,) + (None,) * 6


class ifm4no_l1(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, yh3, yh4, g0o, g1o, g0a, g0b, g1a, g1b):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.calc_gradients = yl.requires_grad
        batch, ch, r, c = yl.shape
        ll = yl
        # Level 4 inverse transform with quater shift synthesis filters
        lh = c2q(yh4[:,:,0:6:5])
        hl = c2q(yh4[:,:,2:4:1])
        hh = c2q(yh4[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh3.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 3 inverse transform with quater shift synthesis filters
        lh = c2q(yh3[:,:,0:6:5])
        hl = c2q(yh3[:,:,2:4:1])
        hh = c2q(yh3[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh2.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 2 inverse transform with quater shift synthesis filters
        lh = c2q(yh2[:,:,0:6:5])
        hl = c2q(yh2[:,:,2:4:1])
        hh = c2q(yh2[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)

        # Level 1 inverse - no highpasses so only use the
        # Low-low band with biorthogonal synthesis filters
        y = rowfilter(colfilter(ll, g0o), g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None
        grad_yh3 = None
        grad_yh4 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if ctx.calc_gradients:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            # No more processing - hps coeffs are 0
            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 3 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 4 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh4 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            grad_yl = LoLo

        return grad_yl, grad_yh1, grad_yh2, grad_yh3, grad_yh4, None, None, None, None, None, None


class xfm4no_l1(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b):
        ctx.save_for_backward(input.shape, h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.calc_gradients = input.requires_grad
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        LoLo = colfilter(Lo, h0o)
        Yh1 = torch.tensor([])

        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh2 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh3 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 4 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh4 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        Yl = LoLo
        return Yl, Yh1, Yh2, Yh3, Yh4

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2, grad_Yh3, grad_Yh4):
        in_shape, h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if ctx.calc_gradients:
            ll = grad_LoLo
            # Level 4 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh4[:,:,0:6:5])
            hl = c2q(grad_Yh4[:,:,2:4:1])
            hh = c2q(grad_Yh4[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh3.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 3 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh3[:,:,0:6:5])
            hl = c2q(grad_Yh3[:,:,2:4:1])
            hh = c2q(grad_Yh3[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 2 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh2[:,:,0:6:5])
            hl = c2q(grad_Yh2[:,:,2:4:1])
            hh = c2q(grad_Yh2[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = in_shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters). No
            # Highpasses so only need to use the low-low
            grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)

        return (grad_input,) + (None,) * 6


class ifm5(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, yh3, yh4, yh5, g0o, g1o, g0a, g0b, g1a, g1b):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.calc_gradients = yl.requires_grad
        batch, ch, r, c = yl.shape
        ll = yl
        # Level 5 inverse transform with quater shift synthesis filters
        lh = c2q(yh5[:,:,0:6:5])
        hl = c2q(yh5[:,:,2:4:1])
        hh = c2q(yh5[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh4.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 4 inverse transform with quater shift synthesis filters
        lh = c2q(yh4[:,:,0:6:5])
        hl = c2q(yh4[:,:,2:4:1])
        hh = c2q(yh4[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh3.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 3 inverse transform with quater shift synthesis filters
        lh = c2q(yh3[:,:,0:6:5])
        hl = c2q(yh3[:,:,2:4:1])
        hh = c2q(yh3[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh2.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 2 inverse transform with quater shift synthesis filters
        lh = c2q(yh2[:,:,0:6:5])
        hl = c2q(yh2[:,:,2:4:1])
        hh = c2q(yh2[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh1.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]
        # Level 1 inverse with biorthogonal synthesis filters
        lh = c2q(yh1[:,:,0:6:5])
        hl = c2q(yh1[:,:,2:4:1])
        hh = c2q(yh1[:,:,1:5:3])
        Hi = colfilter(hh, g1o) + colfilter(hl, g0o)
        Lo = colfilter(lh, g1o) + colfilter(ll, g0o)
        y = rowfilter(Hi, g1o) + rowfilter(Lo, g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None
        grad_yh3 = None
        grad_yh4 = None
        grad_yh5 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if ctx.calc_gradients:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            Hi = rowfilter(grad_y, g1o_t)
            LoHi = colfilter(Lo, g1o_t)
            HiLo = colfilter(Hi, g0o_t)
            HiHi = colfilter(Hi, g1o_t)
            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 3 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 4 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh4 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 5 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh5 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            grad_yl = LoLo

        return grad_yl, grad_yh1, grad_yh2, grad_yh3, grad_yh4, grad_yh5, None, None, None, None, None, None


class xfm5(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b):
        ctx.save_for_backward(input.shape, h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.calc_gradients = input.requires_grad
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        LoLo = colfilter(Lo, h0o)
        Hi = rowfilter(input, h1o)
        LoHi = colfilter(Lo, h1o)
        HiLo = colfilter(Hi, h0o)
        HiHi = colfilter(Hi, h1o)
        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh1 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh2 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh3 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 4 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh4 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 5 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh5 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        Yl = LoLo
        return Yl, Yh1, Yh2, Yh3, Yh4, Yh5

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2, grad_Yh3, grad_Yh4, grad_Yh5):
        in_shape, h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if ctx.calc_gradients:
            ll = grad_LoLo
            # Level 5 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh5[:,:,0:6:5])
            hl = c2q(grad_Yh5[:,:,2:4:1])
            hh = c2q(grad_Yh5[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh4.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 4 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh4[:,:,0:6:5])
            hl = c2q(grad_Yh4[:,:,2:4:1])
            hh = c2q(grad_Yh4[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh3.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 3 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh3[:,:,0:6:5])
            hl = c2q(grad_Yh3[:,:,2:4:1])
            hh = c2q(grad_Yh3[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 2 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh2[:,:,0:6:5])
            hl = c2q(grad_Yh2[:,:,2:4:1])
            hh = c2q(grad_Yh2[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters)
            lh = c2q(grad_Yh1[:,:,0:6:5])
            hl = c2q(grad_Yh1[:,:,2:4:1])
            hh = c2q(grad_Yh1[:,:,1:5:3])
            Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
            Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
            grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)

        return (grad_input,) + (None,) * 6


class ifm5no_l1(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, yh3, yh4, yh5, g0o, g1o, g0a, g0b, g1a, g1b):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.calc_gradients = yl.requires_grad
        batch, ch, r, c = yl.shape
        ll = yl
        # Level 5 inverse transform with quater shift synthesis filters
        lh = c2q(yh5[:,:,0:6:5])
        hl = c2q(yh5[:,:,2:4:1])
        hh = c2q(yh5[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh4.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 4 inverse transform with quater shift synthesis filters
        lh = c2q(yh4[:,:,0:6:5])
        hl = c2q(yh4[:,:,2:4:1])
        hh = c2q(yh4[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh3.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 3 inverse transform with quater shift synthesis filters
        lh = c2q(yh3[:,:,0:6:5])
        hl = c2q(yh3[:,:,2:4:1])
        hh = c2q(yh3[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh2.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 2 inverse transform with quater shift synthesis filters
        lh = c2q(yh2[:,:,0:6:5])
        hl = c2q(yh2[:,:,2:4:1])
        hh = c2q(yh2[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)

        # Level 1 inverse - no highpasses so only use the
        # Low-low band with biorthogonal synthesis filters
        y = rowfilter(colfilter(ll, g0o), g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None
        grad_yh3 = None
        grad_yh4 = None
        grad_yh5 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if ctx.calc_gradients:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            # No more processing - hps coeffs are 0
            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 3 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 4 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh4 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 5 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh5 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            grad_yl = LoLo

        return grad_yl, grad_yh1, grad_yh2, grad_yh3, grad_yh4, grad_yh5, None, None, None, None, None, None


class xfm5no_l1(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b):
        ctx.save_for_backward(input.shape, h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.calc_gradients = input.requires_grad
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        LoLo = colfilter(Lo, h0o)
        Yh1 = torch.tensor([])

        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh2 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh3 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 4 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh4 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 5 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh5 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        Yl = LoLo
        return Yl, Yh1, Yh2, Yh3, Yh4, Yh5

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2, grad_Yh3, grad_Yh4, grad_Yh5):
        in_shape, h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if ctx.calc_gradients:
            ll = grad_LoLo
            # Level 5 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh5[:,:,0:6:5])
            hl = c2q(grad_Yh5[:,:,2:4:1])
            hh = c2q(grad_Yh5[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh4.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 4 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh4[:,:,0:6:5])
            hl = c2q(grad_Yh4[:,:,2:4:1])
            hh = c2q(grad_Yh4[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh3.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 3 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh3[:,:,0:6:5])
            hl = c2q(grad_Yh3[:,:,2:4:1])
            hh = c2q(grad_Yh3[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 2 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh2[:,:,0:6:5])
            hl = c2q(grad_Yh2[:,:,2:4:1])
            hh = c2q(grad_Yh2[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = in_shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters). No
            # Highpasses so only need to use the low-low
            grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)

        return (grad_input,) + (None,) * 6


class ifm6(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, yh3, yh4, yh5, yh6, g0o, g1o, g0a, g0b, g1a, g1b):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.calc_gradients = yl.requires_grad
        batch, ch, r, c = yl.shape
        ll = yl
        # Level 6 inverse transform with quater shift synthesis filters
        lh = c2q(yh6[:,:,0:6:5])
        hl = c2q(yh6[:,:,2:4:1])
        hh = c2q(yh6[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh5.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 5 inverse transform with quater shift synthesis filters
        lh = c2q(yh5[:,:,0:6:5])
        hl = c2q(yh5[:,:,2:4:1])
        hh = c2q(yh5[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh4.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 4 inverse transform with quater shift synthesis filters
        lh = c2q(yh4[:,:,0:6:5])
        hl = c2q(yh4[:,:,2:4:1])
        hh = c2q(yh4[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh3.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 3 inverse transform with quater shift synthesis filters
        lh = c2q(yh3[:,:,0:6:5])
        hl = c2q(yh3[:,:,2:4:1])
        hh = c2q(yh3[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh2.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 2 inverse transform with quater shift synthesis filters
        lh = c2q(yh2[:,:,0:6:5])
        hl = c2q(yh2[:,:,2:4:1])
        hh = c2q(yh2[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh1.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]
        # Level 1 inverse with biorthogonal synthesis filters
        lh = c2q(yh1[:,:,0:6:5])
        hl = c2q(yh1[:,:,2:4:1])
        hh = c2q(yh1[:,:,1:5:3])
        Hi = colfilter(hh, g1o) + colfilter(hl, g0o)
        Lo = colfilter(lh, g1o) + colfilter(ll, g0o)
        y = rowfilter(Hi, g1o) + rowfilter(Lo, g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None
        grad_yh3 = None
        grad_yh4 = None
        grad_yh5 = None
        grad_yh6 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if ctx.calc_gradients:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            Hi = rowfilter(grad_y, g1o_t)
            LoHi = colfilter(Lo, g1o_t)
            HiLo = colfilter(Hi, g0o_t)
            HiHi = colfilter(Hi, g1o_t)
            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 3 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 4 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh4 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 5 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh5 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 6 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh6 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            grad_yl = LoLo

        return grad_yl, grad_yh1, grad_yh2, grad_yh3, grad_yh4, grad_yh5, grad_yh6, None, None, None, None, None, None


class xfm6(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b):
        ctx.save_for_backward(input.shape, h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.calc_gradients = input.requires_grad
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        LoLo = colfilter(Lo, h0o)
        Hi = rowfilter(input, h1o)
        LoHi = colfilter(Lo, h1o)
        HiLo = colfilter(Hi, h0o)
        HiHi = colfilter(Hi, h1o)
        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh1 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh2 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh3 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 4 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh4 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 5 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh5 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 6 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh6 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        Yl = LoLo
        return Yl, Yh1, Yh2, Yh3, Yh4, Yh5, Yh6

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2, grad_Yh3, grad_Yh4, grad_Yh5, grad_Yh6):
        in_shape, h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if ctx.calc_gradients:
            ll = grad_LoLo
            # Level 6 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh6[:,:,0:6:5])
            hl = c2q(grad_Yh6[:,:,2:4:1])
            hh = c2q(grad_Yh6[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh5.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 5 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh5[:,:,0:6:5])
            hl = c2q(grad_Yh5[:,:,2:4:1])
            hh = c2q(grad_Yh5[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh4.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 4 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh4[:,:,0:6:5])
            hl = c2q(grad_Yh4[:,:,2:4:1])
            hh = c2q(grad_Yh4[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh3.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 3 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh3[:,:,0:6:5])
            hl = c2q(grad_Yh3[:,:,2:4:1])
            hh = c2q(grad_Yh3[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 2 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh2[:,:,0:6:5])
            hl = c2q(grad_Yh2[:,:,2:4:1])
            hh = c2q(grad_Yh2[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters)
            lh = c2q(grad_Yh1[:,:,0:6:5])
            hl = c2q(grad_Yh1[:,:,2:4:1])
            hh = c2q(grad_Yh1[:,:,1:5:3])
            Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
            Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
            grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)

        return (grad_input,) + (None,) * 6


class ifm6no_l1(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, yh3, yh4, yh5, yh6, g0o, g1o, g0a, g0b, g1a, g1b):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.calc_gradients = yl.requires_grad
        batch, ch, r, c = yl.shape
        ll = yl
        # Level 6 inverse transform with quater shift synthesis filters
        lh = c2q(yh6[:,:,0:6:5])
        hl = c2q(yh6[:,:,2:4:1])
        hh = c2q(yh6[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh5.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 5 inverse transform with quater shift synthesis filters
        lh = c2q(yh5[:,:,0:6:5])
        hl = c2q(yh5[:,:,2:4:1])
        hh = c2q(yh5[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh4.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 4 inverse transform with quater shift synthesis filters
        lh = c2q(yh4[:,:,0:6:5])
        hl = c2q(yh4[:,:,2:4:1])
        hh = c2q(yh4[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh3.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 3 inverse transform with quater shift synthesis filters
        lh = c2q(yh3[:,:,0:6:5])
        hl = c2q(yh3[:,:,2:4:1])
        hh = c2q(yh3[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh2.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 2 inverse transform with quater shift synthesis filters
        lh = c2q(yh2[:,:,0:6:5])
        hl = c2q(yh2[:,:,2:4:1])
        hh = c2q(yh2[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)

        # Level 1 inverse - no highpasses so only use the
        # Low-low band with biorthogonal synthesis filters
        y = rowfilter(colfilter(ll, g0o), g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None
        grad_yh3 = None
        grad_yh4 = None
        grad_yh5 = None
        grad_yh6 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if ctx.calc_gradients:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            # No more processing - hps coeffs are 0
            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 3 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 4 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh4 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 5 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh5 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 6 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh6 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            grad_yl = LoLo

        return grad_yl, grad_yh1, grad_yh2, grad_yh3, grad_yh4, grad_yh5, grad_yh6, None, None, None, None, None, None


class xfm6no_l1(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b):
        ctx.save_for_backward(input.shape, h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.calc_gradients = input.requires_grad
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        LoLo = colfilter(Lo, h0o)
        Yh1 = torch.tensor([])

        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh2 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh3 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 4 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh4 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 5 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh5 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 6 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh6 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        Yl = LoLo
        return Yl, Yh1, Yh2, Yh3, Yh4, Yh5, Yh6

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2, grad_Yh3, grad_Yh4, grad_Yh5, grad_Yh6):
        in_shape, h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if ctx.calc_gradients:
            ll = grad_LoLo
            # Level 6 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh6[:,:,0:6:5])
            hl = c2q(grad_Yh6[:,:,2:4:1])
            hh = c2q(grad_Yh6[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh5.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 5 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh5[:,:,0:6:5])
            hl = c2q(grad_Yh5[:,:,2:4:1])
            hh = c2q(grad_Yh5[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh4.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 4 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh4[:,:,0:6:5])
            hl = c2q(grad_Yh4[:,:,2:4:1])
            hh = c2q(grad_Yh4[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh3.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 3 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh3[:,:,0:6:5])
            hl = c2q(grad_Yh3[:,:,2:4:1])
            hh = c2q(grad_Yh3[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 2 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh2[:,:,0:6:5])
            hl = c2q(grad_Yh2[:,:,2:4:1])
            hh = c2q(grad_Yh2[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = in_shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters). No
            # Highpasses so only need to use the low-low
            grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)

        return (grad_input,) + (None,) * 6


class ifm7(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, yh3, yh4, yh5, yh6, yh7, g0o, g1o, g0a, g0b, g1a, g1b):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.calc_gradients = yl.requires_grad
        batch, ch, r, c = yl.shape
        ll = yl
        # Level 7 inverse transform with quater shift synthesis filters
        lh = c2q(yh7[:,:,0:6:5])
        hl = c2q(yh7[:,:,2:4:1])
        hh = c2q(yh7[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh6.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 6 inverse transform with quater shift synthesis filters
        lh = c2q(yh6[:,:,0:6:5])
        hl = c2q(yh6[:,:,2:4:1])
        hh = c2q(yh6[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh5.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 5 inverse transform with quater shift synthesis filters
        lh = c2q(yh5[:,:,0:6:5])
        hl = c2q(yh5[:,:,2:4:1])
        hh = c2q(yh5[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh4.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 4 inverse transform with quater shift synthesis filters
        lh = c2q(yh4[:,:,0:6:5])
        hl = c2q(yh4[:,:,2:4:1])
        hh = c2q(yh4[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh3.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 3 inverse transform with quater shift synthesis filters
        lh = c2q(yh3[:,:,0:6:5])
        hl = c2q(yh3[:,:,2:4:1])
        hh = c2q(yh3[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh2.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 2 inverse transform with quater shift synthesis filters
        lh = c2q(yh2[:,:,0:6:5])
        hl = c2q(yh2[:,:,2:4:1])
        hh = c2q(yh2[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh1.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]
        # Level 1 inverse with biorthogonal synthesis filters
        lh = c2q(yh1[:,:,0:6:5])
        hl = c2q(yh1[:,:,2:4:1])
        hh = c2q(yh1[:,:,1:5:3])
        Hi = colfilter(hh, g1o) + colfilter(hl, g0o)
        Lo = colfilter(lh, g1o) + colfilter(ll, g0o)
        y = rowfilter(Hi, g1o) + rowfilter(Lo, g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None
        grad_yh3 = None
        grad_yh4 = None
        grad_yh5 = None
        grad_yh6 = None
        grad_yh7 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if ctx.calc_gradients:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            Hi = rowfilter(grad_y, g1o_t)
            LoHi = colfilter(Lo, g1o_t)
            HiLo = colfilter(Hi, g0o_t)
            HiHi = colfilter(Hi, g1o_t)
            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 3 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 4 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh4 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 5 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh5 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 6 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh6 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 7 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh7 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            grad_yl = LoLo

        return grad_yl, grad_yh1, grad_yh2, grad_yh3, grad_yh4, grad_yh5, grad_yh6, grad_yh7, None, None, None, None, None, None


class xfm7(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b):
        ctx.save_for_backward(input.shape, h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.calc_gradients = input.requires_grad
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        LoLo = colfilter(Lo, h0o)
        Hi = rowfilter(input, h1o)
        LoHi = colfilter(Lo, h1o)
        HiLo = colfilter(Hi, h0o)
        HiHi = colfilter(Hi, h1o)
        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh1 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh2 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh3 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 4 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh4 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 5 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh5 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 6 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh6 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 7 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh7 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        Yl = LoLo
        return Yl, Yh1, Yh2, Yh3, Yh4, Yh5, Yh6, Yh7

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2, grad_Yh3, grad_Yh4, grad_Yh5, grad_Yh6, grad_Yh7):
        in_shape, h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if ctx.calc_gradients:
            ll = grad_LoLo
            # Level 7 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh7[:,:,0:6:5])
            hl = c2q(grad_Yh7[:,:,2:4:1])
            hh = c2q(grad_Yh7[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh6.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 6 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh6[:,:,0:6:5])
            hl = c2q(grad_Yh6[:,:,2:4:1])
            hh = c2q(grad_Yh6[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh5.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 5 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh5[:,:,0:6:5])
            hl = c2q(grad_Yh5[:,:,2:4:1])
            hh = c2q(grad_Yh5[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh4.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 4 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh4[:,:,0:6:5])
            hl = c2q(grad_Yh4[:,:,2:4:1])
            hh = c2q(grad_Yh4[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh3.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 3 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh3[:,:,0:6:5])
            hl = c2q(grad_Yh3[:,:,2:4:1])
            hh = c2q(grad_Yh3[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 2 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh2[:,:,0:6:5])
            hl = c2q(grad_Yh2[:,:,2:4:1])
            hh = c2q(grad_Yh2[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters)
            lh = c2q(grad_Yh1[:,:,0:6:5])
            hl = c2q(grad_Yh1[:,:,2:4:1])
            hh = c2q(grad_Yh1[:,:,1:5:3])
            Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
            Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
            grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)

        return (grad_input,) + (None,) * 6


class ifm7no_l1(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, yh3, yh4, yh5, yh6, yh7, g0o, g1o, g0a, g0b, g1a, g1b):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.calc_gradients = yl.requires_grad
        batch, ch, r, c = yl.shape
        ll = yl
        # Level 7 inverse transform with quater shift synthesis filters
        lh = c2q(yh7[:,:,0:6:5])
        hl = c2q(yh7[:,:,2:4:1])
        hh = c2q(yh7[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh6.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 6 inverse transform with quater shift synthesis filters
        lh = c2q(yh6[:,:,0:6:5])
        hl = c2q(yh6[:,:,2:4:1])
        hh = c2q(yh6[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh5.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 5 inverse transform with quater shift synthesis filters
        lh = c2q(yh5[:,:,0:6:5])
        hl = c2q(yh5[:,:,2:4:1])
        hh = c2q(yh5[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh4.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 4 inverse transform with quater shift synthesis filters
        lh = c2q(yh4[:,:,0:6:5])
        hl = c2q(yh4[:,:,2:4:1])
        hh = c2q(yh4[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh3.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 3 inverse transform with quater shift synthesis filters
        lh = c2q(yh3[:,:,0:6:5])
        hl = c2q(yh3[:,:,2:4:1])
        hh = c2q(yh3[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        r, c = ll.shape[2:]
        r1, c1 = yh2.shape[3:5]
        if r != r1 * 2:
            ll = ll[:,:,1:-1]
        if c != c1 * 2:
            ll = ll[:,:,:,1:-1]

        # Level 2 inverse transform with quater shift synthesis filters
        lh = c2q(yh2[:,:,0:6:5])
        hl = c2q(yh2[:,:,2:4:1])
        hh = c2q(yh2[:,:,1:5:3])
        Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
        Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
        ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)

        # Level 1 inverse - no highpasses so only use the
        # Low-low band with biorthogonal synthesis filters
        y = rowfilter(colfilter(ll, g0o), g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None
        grad_yh3 = None
        grad_yh4 = None
        grad_yh5 = None
        grad_yh6 = None
        grad_yh7 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if ctx.calc_gradients:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            # No more processing - hps coeffs are 0
            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 3 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 4 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh4 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 5 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh5 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 6 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh6 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            # Level 7 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
            HiLo = coldfilt(Hi, g0b_t, g0a_t)
            HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

            deg15, deg165 = q2c(LoHi)
            deg45, deg135 = q2c(HiHi)
            deg75, deg105 = q2c(HiLo)
            grad_yh7 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)
            grad_yl = LoLo

        return grad_yl, grad_yh1, grad_yh2, grad_yh3, grad_yh4, grad_yh5, grad_yh6, grad_yh7, None, None, None, None, None, None


class xfm7no_l1(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b):
        ctx.save_for_backward(input.shape, h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.calc_gradients = input.requires_grad
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        LoLo = colfilter(Lo, h0o)
        Yh1 = torch.tensor([])

        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh2 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh3 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 4 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh4 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 5 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh5 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 6 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh6 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        # Level 7 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
        LoLo = coldfilt(Lo, h0b, h0a)
        LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
        HiLo = coldfilt(Hi, h0b, h0a)
        HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

        deg15, deg165 = q2c(LoHi)
        deg45, deg135 = q2c(HiHi)
        deg75, deg105 = q2c(HiLo)
        Yh7 = torch.stack(
            [deg15, deg45, deg75, deg105, deg135, deg165], dim=2)

        Yl = LoLo
        return Yl, Yh1, Yh2, Yh3, Yh4, Yh5, Yh6, Yh7

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2, grad_Yh3, grad_Yh4, grad_Yh5, grad_Yh6, grad_Yh7):
        in_shape, h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if ctx.calc_gradients:
            ll = grad_LoLo
            # Level 7 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh7[:,:,0:6:5])
            hl = c2q(grad_Yh7[:,:,2:4:1])
            hh = c2q(grad_Yh7[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh6.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 6 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh6[:,:,0:6:5])
            hl = c2q(grad_Yh6[:,:,2:4:1])
            hh = c2q(grad_Yh6[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh5.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 5 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh5[:,:,0:6:5])
            hl = c2q(grad_Yh5[:,:,2:4:1])
            hh = c2q(grad_Yh5[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh4.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 4 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh4[:,:,0:6:5])
            hl = c2q(grad_Yh4[:,:,2:4:1])
            hh = c2q(grad_Yh4[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh3.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 3 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh3[:,:,0:6:5])
            hl = c2q(grad_Yh3[:,:,2:4:1])
            hh = c2q(grad_Yh3[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 2 backward (time reversed quater shift analysis filters)
            lh = c2q(grad_Yh2[:,:,0:6:5])
            hl = c2q(grad_Yh2[:,:,2:4:1])
            hh = c2q(grad_Yh2[:,:,1:5:3])
            Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
            Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
            ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = in_shape[3:5]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters). No
            # Highpasses so only need to use the low-low
            grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)

        return (grad_input,) + (None,) * 6

